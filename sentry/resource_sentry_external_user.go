package sentry

import (
	"context"
	"fmt"
	"net/http"
	"strconv"

	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	gosentry "github.com/mzglinski/go-sentry/v2/sentry"
	"github.com/mzglinski/terraform-provider-sentry/internal/providerdata"
	"github.com/mzglinski/terraform-provider-sentry/internal/tfutils"
)

func resourceSentryExternalUser() *schema.Resource {
	return &schema.Resource{
		Description: "Manages Sentry external user mappings.",

		CreateContext: resourceSentryExternalUserCreate,
		ReadContext:   resourceSentryExternalUserRead,
		UpdateContext: resourceSentryExternalUserUpdate,
		DeleteContext: resourceSentryExternalUserDelete,

		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},

		Schema: map[string]*schema.Schema{
			"organization": {
				Description: "The slug of the organization the resource belongs to.",
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
			},
			"user_id": {
				Description: "The user ID in Sentry.",
				Type:        schema.TypeInt,
				Required:    true,
			},
			"external_name": {
				Description: "The associated name for the provider.",
				Type:        schema.TypeString,
				Required:    true,
			},
			"external_provider": {
				Description: "The provider of the external actor (e.g., \"gitlab\").",
				Type:        schema.TypeString,
				Required:    true,
				ValidateFunc: validation.StringInSlice([]string{
					"github",
					"github_enterprise",
					"jira_server",
					"slack",
					"gitlab",
					"msteams",
					"custom_scm",
				}, false),
			},
			"integration_id": {
				Description: "The Integration ID.",
				Type:        schema.TypeInt,
				Required:    true,
			},
			"external_id": {
				Description: "The external actor ID for the provider (e.g., GitLab User ID).",
				Type:        schema.TypeString,
				Required:    true,
			},
			"internal_id": {
				Description: "The internal ID for this external user mapping (generated by Sentry).",
				Type:        schema.TypeString,
				Computed:    true,
			},
		},
	}
}

func resourceSentryExternalUserCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*providerdata.ProviderData).Client

	org := d.Get("organization").(string)
	externalIDStr := d.Get("external_id").(string)
	externalActorID, err := strconv.Atoi(externalIDStr)
	if err != nil {
		return diag.Errorf("Error converting external_id to integer: %s", err)
	}

	params := &gosentry.CreateExternalUserParams{
		UserID:           d.Get("user_id").(int),
		ExternalName:     d.Get("external_name").(string),
		ExternalProvider: d.Get("external_provider").(string),
		IntegrationID:    d.Get("integration_id").(int),
		ID:               externalActorID,
	}

	tflog.Debug(ctx, "Creating Sentry external user mapping", map[string]interface{}{
		"org":                org,
		"userID":             params.UserID,
		"externalName":       params.ExternalName,
		"externalProvider":   params.ExternalProvider,
		"integrationID":      params.IntegrationID,
		"externalActorID":    params.ID,
	})

	externalUser, resp, err := client.ExternalUsers.Create(ctx, org, params)
	if err != nil {
		return diag.FromErr(err)
	}
	if resp.StatusCode != http.StatusCreated {
		return diag.Errorf("Error creating Sentry external user: %s, status code: %d, body: %s", resp.Status, resp.StatusCode, resp.Body)
	}

	d.SetId(tfutils.BuildTwoPartId(org, externalUser.ID))
	if err := d.Set("internal_id", externalUser.ID); err != nil {
		return diag.FromErr(err)
	}

	return resourceSentryExternalUserRead(ctx, d, meta)
}

func resourceSentryExternalUserUpdate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*providerdata.ProviderData).Client

	org, externalUserMappingID, err := tfutils.SplitTwoPartId(d.Id(), "organization", "sentry_external_user_mapping_id")
	if err != nil {
		return diag.Errorf("Error splitting ID: %s", err)
	}

	if !d.HasChanges("user_id", "external_name", "external_provider", "integration_id", "external_id") {
		tflog.Debug(ctx, "No changes detected for Sentry external user mapping")
		return nil
	}

	externalIDStr := d.Get("external_id").(string)
	externalActorID, err := strconv.Atoi(externalIDStr)
	if err != nil {
		return diag.Errorf("Error converting external_id to integer: %s", err)
	}

	params := &gosentry.UpdateExternalUserParams{
		UserID:           d.Get("user_id").(int),
		ExternalName:     d.Get("external_name").(string),
		ExternalProvider: d.Get("external_provider").(string),
		IntegrationID:    d.Get("integration_id").(int),
		ID:               externalActorID,
	}

	tflog.Debug(ctx, "Updating Sentry external user mapping", map[string]interface{}{
		"org":                   org,
		"externalUserMappingID": externalUserMappingID,
		"userID":                params.UserID,
		"externalName":          params.ExternalName,
		"externalProvider":      params.ExternalProvider,
		"integrationID":         params.IntegrationID,
		"externalActorID":       params.ID,
	})

	updatedExternalUser, resp, err := client.ExternalUsers.Update(ctx, org, externalUserMappingID, params)
	if err != nil {
		return diag.FromErr(err)
	}
	if resp.StatusCode != http.StatusOK {
		return diag.Errorf("Error updating Sentry external user: %s, status code: %d, body: %s", resp.Status, resp.StatusCode, resp.Body)
	}

	if err := d.Set("internal_id", updatedExternalUser.ID); err != nil {
		return diag.FromErr(err)
	}

	return resourceSentryExternalUserRead(ctx, d, meta)
}

func resourceSentryExternalUserRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	org, externalUserMappingID, err := tfutils.SplitTwoPartId(d.Id(), "organization", "sentry_external_user_mapping_id")
	if err != nil {
		tflog.Warn(ctx, fmt.Sprintf("Error parsing resource ID '%s': %s. Proceeding with caution.", d.Id(), err))
	}

	var diags diag.Diagnostics

	if orgFromID := org; orgFromID != "" {
		if err := d.Set("organization", orgFromID); err != nil {
			diags = append(diags, diag.FromErr(err)...)
		}
	} else {
		if err := d.Set("organization", d.Get("organization")); err != nil {
			diags = append(diags, diag.FromErr(err)...)
		}
	}

	if externalUserMappingID != "" {
		if err := d.Set("internal_id", externalUserMappingID); err != nil {
			diags = append(diags, diag.FromErr(err)...)
		}
	} else if d.Get("internal_id").(string) == "" && d.Id() != "" {
		_, parsedMappingID, _ := tfutils.SplitTwoPartId(d.Id(), "organization", "sentry_external_user_mapping_id")
		if parsedMappingID != "" {
			if err := d.Set("internal_id", parsedMappingID); err != nil {
				diags = append(diags, diag.FromErr(err)...)
			}
		}
	}

	fieldsToSet := []string{"user_id", "external_name", "external_provider", "integration_id", "external_id"}
	for _, field := range fieldsToSet {
		if err := d.Set(field, d.Get(field)); err != nil {
			diags = append(diags, diag.FromErr(err)...)
		}
	}

	return diags
}

func resourceSentryExternalUserDelete(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*providerdata.ProviderData).Client

	org, externalUserID, err := tfutils.SplitTwoPartId(d.Id(), "organization", "external_user_id")
	if err != nil {
		return diag.FromErr(err)
	}

	tflog.Debug(ctx, "Deleting Sentry external user mapping", map[string]interface{}{
		"org":            org,
		"externalUserID": externalUserID,
	})

	resp, err := client.ExternalUsers.Delete(ctx, org, externalUserID)
	if err != nil {
		if resp != nil && resp.StatusCode == http.StatusNotFound {
			tflog.Info(ctx, "External user mapping not found, removing from state", map[string]interface{}{
				"org":            org,
				"externalUserMappingID": externalUserID,
			})
			d.SetId("")
			return nil
		}
		return diag.FromErr(err)
	}
	if resp.StatusCode != http.StatusNoContent {
		return diag.Errorf("Error deleting Sentry external user mapping: %s, status: %d", resp.Status, resp.StatusCode)
	}

	return nil
} 